<!DOCTYPE html>
<html lang="ko" style="color-scheme: light only; background-color: #ffe9f0; color: #333333;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light">
    <meta name="supported-color-schemes" content="light">
    <meta name="theme-color" content="#ffe9f0" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#ffe9f0" media="(prefers-color-scheme: dark)">
    <title>메시지 전송</title>
    <link rel="stylesheet" href="style.css">
    <style>
        html {
            color-scheme: light only !important;
            background-color: #ffe9f0 !important;
            color: #333333 !important;
            -webkit-color-scheme: light only !important;
        }
        body {
            background:
                radial-gradient(circle at 0% 0%, rgba(255, 255, 255, 0.9) 0, rgba(255, 255, 255, 0) 55%),
                radial-gradient(circle at 100% 100%, rgba(255, 255, 255, 0.95) 0, rgba(255, 255, 255, 0) 55%),
                linear-gradient(135deg, #ffe9f0 0%, #fff4d9 40%, #e3f3ff 80%, #e5ddff 100%) !important;
            background-color: #ffe9f0 !important;
            color: #333333 !important;
        }

        .bg-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: -3;
            pointer-events: none;
        }

        .bg-vignette {
            position: fixed;
            inset: -20px;
            pointer-events: none;
            z-index: -2;
            background:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.55) 0, rgba(255, 255, 255, 0) 55%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.45) 0, rgba(255, 255, 255, 0) 60%),
                radial-gradient(circle at 50% -10%, rgba(255, 255, 255, 0.55) 0, rgba(255, 255, 255, 0) 55%);
            mix-blend-mode: screen;
            opacity: 0.9;
        }

        .effect-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body style="background: linear-gradient(135deg, #ffe9f0 0%, #fff4d9 40%, #e3f3ff 80%, #e5ddff 100%); background-color: #ffe9f0; color: #333333;">
    <canvas id="bgCanvas" class="bg-canvas" aria-hidden="true"></canvas>
    <canvas id="effectCanvas" class="effect-canvas" aria-hidden="true"></canvas>
    <div class="bg-vignette" aria-hidden="true"></div>
    <div class="bg-orbs" aria-hidden="true">
        <span class="orb o1"></span>
        <span class="orb o2"></span>
        <span class="orb o3"></span>
        <span class="orb o4"></span>
    </div>
    <div class="container">
        <div class="page-hero" aria-label="페이지 안내">
            <div class="hero-kicker">DSM 졸업 축하 메시지</div>
            <div class="hero-title">DSM 졸업을 진심으로 축하합니다</div>
            <p class="hero-subtitle">따뜻한 한마디를 남기면, 메시지 공이 되어 함께 떠올라요.</p>
        </div>
        <form id="messageForm">
            <div class="form-group">
                <label for="message">메시지</label>
                <textarea id="message" rows="5" required maxlength="500" placeholder="메시지를 입력하세요"></textarea>
                <div class="char-count"><span id="charCount">0</span>/500</div>
            </div>
            <button type="submit" id="submitBtn">전송</button>
        </form>
        <div id="status"></div>
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="client-send.js"></script>
    <script>
        // Background animation
        (() => {
            const canvas = document.getElementById('bgCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
            if (!ctx) return;

            const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const DPR = Math.min(2, window.devicePixelRatio || 1);

            let w = 0, h = 0;
            let rafId = 0;
            let last = performance.now();

            const rnd = (a, b) => a + Math.random() * (b - a);

            const palette = [
                [255, 164, 198], // rose
                [255, 205, 146], // peach
                [170, 222, 255], // sky
                [210, 196, 255], // lavender
                [200, 255, 214], // mint
            ];

            const blobs = Array.from({ length: 14 }, () => {
                const c = palette[(Math.random() * palette.length) | 0];
                const size = rnd(90, 240);
                return {
                    x: rnd(0, 1),
                    y: rnd(0, 1),
                    r: size,
                    a: rnd(0.05, 0.12),
                    vx: rnd(-0.015, 0.015),
                    vy: rnd(-0.015, 0.015),
                    p: rnd(0, Math.PI * 2),
                    ps: rnd(0.08, 0.16),
                    c,
                };
            });

            function resize() {
                w = Math.max(1, window.innerWidth);
                h = Math.max(1, window.innerHeight);
                canvas.width = Math.floor(w * DPR);
                canvas.height = Math.floor(h * DPR);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            }

            function draw(now) {
                const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
                last = now;

                ctx.clearRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255,255,255,0)';
                ctx.fillRect(0, 0, w, h);

                ctx.globalCompositeOperation = 'lighter';

                for (let i = 0; i < blobs.length; i++) {
                    const b = blobs[i];
                    b.p += b.ps * dt;

                    if (!prefersReduced) {
                        b.x += b.vx * dt;
                        b.y += b.vy * dt;
                    }

                    if (b.x < -0.15) b.x = 1.15;
                    if (b.x > 1.15) b.x = -0.15;
                    if (b.y < -0.15) b.y = 1.15;
                    if (b.y > 1.15) b.y = -0.15;

                    const px = b.x * w + Math.sin(b.p) * 18;
                    const py = b.y * h + Math.cos(b.p * 0.9) * 16;
                    const rr = b.r * (0.92 + Math.sin(b.p * 0.7) * 0.08);

                    const g = ctx.createRadialGradient(px - rr * 0.22, py - rr * 0.18, rr * 0.1, px, py, rr);
                    g.addColorStop(0, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},${b.a})`);
                    g.addColorStop(0.65, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},${b.a * 0.55})`);
                    g.addColorStop(1, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},0)`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, rr, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = 'source-over';
                rafId = requestAnimationFrame(draw);
            }

            resize();
            window.addEventListener('resize', resize, { passive: true });
            rafId = requestAnimationFrame(draw);
        })();

        // Cannon Effect Animation
        (() => {
            const canvas = document.getElementById('effectCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d', { alpha: true });
            if (!ctx) return;

            const DPR = Math.min(2, window.devicePixelRatio || 1);
            let w = 0, h = 0;
            let rafId = 0;
            let last = performance.now();

            const rnd = (a, b) => a + Math.random() * (b - a);

            const colorPalette = [
                [255, 107, 178], // hot pink
                [255, 165, 0],   // orange
                [138, 203, 255], // sky blue
                [186, 148, 255], // purple
                [255, 223, 0],   // yellow
                [100, 255, 150], // mint green
                [255, 100, 100], // red
                [100, 200, 255], // light blue
            ];

            let balls = [];
            let particles = [];
            let stars = [];
            let rings = [];
            let cannon = {
                x: 0,
                y: 0,
                recoil: 0,
                angle: -45 * Math.PI / 180,  // 오른쪽 위 45도
                scale: 1.5
            };

            function resize() {
                w = Math.max(1, window.innerWidth);
                h = Math.max(1, window.innerHeight);
                canvas.width = Math.floor(w * DPR);
                canvas.height = Math.floor(h * DPR);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

                // 왼쪽 아래 위치
                cannon.x = 150;
                cannon.y = h - 100;
            }

            function createBall(message) {
                const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                const speed = rnd(20, 25);  // 더 빠르게
                
                return {
                    x: cannon.x + Math.cos(cannon.angle) * 90 * cannon.scale,
                    y: cannon.y + Math.sin(cannon.angle) * 90 * cannon.scale,
                    vx: Math.cos(cannon.angle) * speed,
                    vy: Math.sin(cannon.angle) * speed,
                    radius: rnd(30, 45),
                    color: color,
                    message: message.substring(0, 15),
                    rotation: 0,
                    rotationSpeed: rnd(-0.08, 0.08),
                    life: 1.0,
                    trail: [],
                    glow: 1.0,
                    pulsePhase: 0
                };
            }

            function createExplosion() {
                const count = 60;  // 더 많은 파티클
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i / count) + rnd(-0.3, 0.3);
                    const speed = rnd(4, 12);
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    
                    particles.push({
                        x: cannon.x + Math.cos(cannon.angle) * 75 * cannon.scale,
                        y: cannon.y + Math.sin(cannon.angle) * 75 * cannon.scale,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: rnd(4, 9),
                        color: color,
                        life: 1.0,
                        decay: rnd(0.012, 0.02),
                        glow: true
                    });
                }

                // 폭발 링 추가
                for (let i = 0; i < 3; i++) {
                    rings.push({
                        x: cannon.x + Math.cos(cannon.angle) * 75 * cannon.scale,
                        y: cannon.y + Math.sin(cannon.angle) * 75 * cannon.scale,
                        radius: 0,
                        maxRadius: rnd(80, 120),
                        speed: rnd(3, 5),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        width: rnd(3, 6)
                    });
                }
            }

            function createSparkles(x, y, count = 12) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = rnd(2, 5);
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: rnd(2, 5),
                        color: color,
                        life: 1.0,
                        decay: rnd(0.02, 0.04),
                        glow: true,
                        sparkle: true
                    });
                }
            }

            function createStars(x, y, count = 8) {
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i / count) + rnd(-0.2, 0.2);
                    const distance = rnd(15, 35);
                    
                    stars.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        size: rnd(8, 15),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        rotation: rnd(0, Math.PI * 2),
                        rotationSpeed: rnd(-0.15, 0.15)
                    });
                }
            }

            function createRainbowTrail(x, y) {
                const count = 5;
                for (let i = 0; i < count; i++) {
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    particles.push({
                        x: x + rnd(-10, 10),
                        y: y + rnd(-10, 10),
                        vx: rnd(-1, 1),
                        vy: rnd(-1, 1),
                        radius: rnd(3, 6),
                        color: color,
                        life: 0.8,
                        decay: 0.03,
                        glow: true
                    });
                }
            }

            function fire(message) {
                cannon.recoil = 20 * cannon.scale;
                createExplosion();
                
                setTimeout(() => {
                    const ball = createBall(message);
                    balls.push(ball);
                    
                    // 발사 시 별 효과
                    createStars(ball.x, ball.y, 12);
                }, 50);
            }

            function drawCannon() {
                ctx.save();
                ctx.translate(cannon.x, cannon.y);
                
                if (cannon.recoil > 0) {
                    const recoilX = Math.cos(cannon.angle) * cannon.recoil;
                    const recoilY = Math.sin(cannon.angle) * cannon.recoil;
                    ctx.translate(recoilX, recoilY);
                    cannon.recoil *= 0.8;
                    if (cannon.recoil < 0.1) cannon.recoil = 0;
                }

                ctx.rotate(cannon.angle);
                ctx.scale(cannon.scale, cannon.scale);

                // Cannon barrel shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.rect(2, -10, 60, 24);
                ctx.fill();

                // Cannon barrel
                const barrelGradient = ctx.createLinearGradient(0, -12, 0, 12);
                barrelGradient.addColorStop(0, '#555');
                barrelGradient.addColorStop(0.5, '#333');
                barrelGradient.addColorStop(1, '#444');
                ctx.fillStyle = barrelGradient;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.rect(0, -12, 60, 24);
                ctx.fill();
                ctx.stroke();

                // Cannon barrel highlight
                ctx.fillStyle = '#777';
                ctx.beginPath();
                ctx.rect(0, -12, 60, 6);
                ctx.fill();

                // Barrel stripes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                for (let i = 10; i < 60; i += 15) {
                    ctx.beginPath();
                    ctx.moveTo(i, -10);
                    ctx.lineTo(i, 10);
                    ctx.stroke();
                }

                ctx.restore();

                // Cannon base
                ctx.save();
                ctx.translate(cannon.x, cannon.y);
                ctx.scale(cannon.scale, cannon.scale);
                
                const baseGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, 20);
                baseGradient.addColorStop(0, '#666');
                baseGradient.addColorStop(1, '#333');
                ctx.fillStyle = baseGradient;
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Wheel decorations
                ctx.fillStyle = '#888';
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i / 8);
                    const wx = Math.cos(angle) * 13;
                    const wy = Math.sin(angle) * 13;
                    ctx.beginPath();
                    ctx.arc(wx, wy, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center decoration
                ctx.fillStyle = '#aaa';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            function update(dt) {
                // Update balls
                for (let i = balls.length - 1; i >= 0; i--) {
                    const b = balls[i];
                    
                    // 직선으로 날아감 (중력 없음)
                    b.x += b.vx;
                    b.y += b.vy;
                    b.rotation += b.rotationSpeed;
                    b.pulsePhase += 0.1;

                    // Trail
                    b.trail.push({ x: b.x, y: b.y, life: 0.8 });
                    if (b.trail.length > 25) b.trail.shift();

                    // 더 화려한 이펙트
                    if (Math.random() < 0.3) {
                        createSparkles(b.x, b.y, 3);
                    }
                    if (Math.random() < 0.15) {
                        createRainbowTrail(b.x, b.y);
                    }
                    if (Math.random() < 0.1) {
                        createStars(b.x, b.y, 2);
                    }

                    // Fade out when reaching top-right
                    if (b.x > w * 0.7 || b.y < h * 0.3) {
                        b.life -= 0.01;
                    }

                    if (b.life <= 0 || b.x > w + 100 || b.y < -100) {
                        balls.splice(i, 1);
                    }
                }

                // Update particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    if (!p.sparkle) {
                        p.vy += 0.15; // 약간의 중력
                    }
                    
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                // Update stars
                for (let i = stars.length - 1; i >= 0; i--) {
                    const s = stars[i];
                    s.rotation += s.rotationSpeed;
                    s.life -= 0.02;

                    if (s.life <= 0) {
                        stars.splice(i, 1);
                    }
                }

                // Update rings
                for (let i = rings.length - 1; i >= 0; i--) {
                    const r = rings[i];
                    r.radius += r.speed;
                    r.life -= 0.015;

                    if (r.radius >= r.maxRadius || r.life <= 0) {
                        rings.splice(i, 1);
                    }
                }
            }

            function drawStar(x, y, size, rotation, alpha) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i / 5) - Math.PI / 2;
                    const outerX = Math.cos(angle) * size;
                    const outerY = Math.sin(angle) * size;
                    const innerAngle = angle + Math.PI / 5;
                    const innerX = Math.cos(innerAngle) * (size * 0.4);
                    const innerY = Math.sin(innerAngle) * (size * 0.4);
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                ctx.restore();
            }

            function draw(now) {
                const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
                last = now;

                ctx.clearRect(0, 0, w, h);

                update(dt);

                // Draw cannon
                drawCannon();

                // Draw rings
                for (const r of rings) {
                    const alpha = r.life * (1 - r.radius / r.maxRadius);
                    ctx.strokeStyle = `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, ${alpha})`;
                    ctx.lineWidth = r.width;
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw particles
                for (const p of particles) {
                    const alpha = p.life;
                    
                    if (p.glow) {
                        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 4);
                        gradient.addColorStop(0, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.8})`);
                        gradient.addColorStop(0.5, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.4})`);
                        gradient.addColorStop(1, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw stars
                for (const s of stars) {
                    const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 2);
                    gradient.addColorStop(0, `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, ${s.life * 0.6})`);
                    gradient.addColorStop(1, `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    drawStar(s.x, s.y, s.size, s.rotation, s.life);
                }

                // Draw balls with trail
                for (const b of balls) {
                    // Trail with rainbow gradient
                    for (let i = 0; i < b.trail.length; i++) {
                        const t = b.trail[i];
                        const progress = i / b.trail.length;
                        const alpha = t.life * progress * b.life * 0.5;
                        const size = b.radius * 0.7 * progress;
                        
                        const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size * 2);
                        gradient.addColorStop(0, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${alpha})`);
                        gradient.addColorStop(1, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Ball outer glow (pulsing)
                    const pulseScale = 1 + Math.sin(b.pulsePhase) * 0.2;
                    const glowGradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.radius * 3 * pulseScale);
                    glowGradient.addColorStop(0, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${b.life * 0.4})`);
                    glowGradient.addColorStop(0.5, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${b.life * 0.2})`);
                    glowGradient.addColorStop(1, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, 0)`);
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 3 * pulseScale, 0, Math.PI * 2);
                    ctx.fill();

                    // Ball
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(b.rotation);

                    const gradient = ctx.createRadialGradient(-b.radius * 0.4, -b.radius * 0.4, 0, 0, 0, b.radius * 1.2);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${b.life})`);
                    gradient.addColorStop(0.3, `rgba(${b.color[0] + 80}, ${b.color[1] + 80}, ${b.color[2] + 80}, ${b.life})`);
                    gradient.addColorStop(1, `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${b.life})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Ball border (double)
                    ctx.strokeStyle = `rgba(255, 255, 255, ${b.life * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.strokeStyle = `rgba(${b.color[0]}, ${b.color[1]}, ${b.color[2]}, ${b.life * 0.6})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, b.radius - 4, 0, Math.PI * 2);
                    ctx.stroke();

                    // Message text with shadow
                    if (b.message && b.life > 0.3) {
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${b.life})`;
                        ctx.font = 'bold 14px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const maxWidth = b.radius * 1.7;
                        const text = b.message.length > 10 ? b.message.substring(0, 10) + '...' : b.message;
                        ctx.fillText(text, 0, 0, maxWidth);
                        
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }

                    ctx.restore();
                }

                rafId = requestAnimationFrame(draw);
            }

            resize();
            window.addEventListener('resize', resize, { passive: true });
            rafId = requestAnimationFrame(draw);

            // Expose fire function globally
            window.cannonEffect = { fire };
        })();
    </script>
</body>
</html>