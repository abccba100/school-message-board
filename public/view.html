<!DOCTYPE html>
<html lang="ko" style="color-scheme: light only; background-color: #ffd7e2; color: #333333;">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>말랑말랑 메시지 보드</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    color-scheme: light only !important;
    background: linear-gradient(135deg, #ffd7e2 0%, #ffe8c7 35%, #e0f2ff 75%, #e3dcff 100%);
    color: #333;
    font-family: "Apple SD Gothic Neo", "Pretendard", sans-serif;
}

#ballContainer {
    position: fixed;
    inset: 0;
}

.message-ball {
    position: absolute;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
    box-sizing: border-box;
    border-radius: 50%;
    border: 2px solid rgba(0,0,0,0.08);
    text-align: center;
    font-size: 14px;
    font-weight: 600;
    line-height: 1.4;
    user-select: none;
    will-change: transform;
}

.bg-canvas,
.effect-canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
}

.bg-canvas { z-index: -2; }
.effect-canvas { z-index: 999; }

#status {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.9);
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 12px;
    display: none;
}
</style>
</head>

<body>
<canvas id="bgCanvas" class="bg-canvas"></canvas>
<canvas id="effectCanvas" class="effect-canvas"></canvas>
<div id="ballContainer"></div>
<div id="status"></div>

<script src="/socket.io/socket.io.js"></script>

<script>
/* =====================================================
   GLOBAL UTIL
===================================================== */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rnd = (a,b)=>a+Math.random()*(b-a);

/* =====================================================
   CONTAINER
===================================================== */
const ballContainer = document.getElementById("ballContainer");
let containerWidth = innerWidth;
let containerHeight = innerHeight;

window.addEventListener("resize", ()=>{
    containerWidth = innerWidth;
    containerHeight = innerHeight;
});

/* =====================================================
   CANNON CONFIG
===================================================== */
const CANNON = {
    x: 150,
    y: ()=>containerHeight-120,
    angle: -45 * Math.PI/180
};

/* =====================================================
   BALL PHYSICS
===================================================== */
const WORLD = {
    drag: 0.96,
    noise: 20,
    maxSpeed: 520,
    collideK: 50,
    collideD: 12
};

class Ball {
    constructor(id, text, x, y){
        this.id=id;
        this.text=text;
        this.x=x;
        this.y=y;
        this.vx=0;
        this.vy=0;
        this.radius=clamp(text.length*3+40,40,100);
        this.mass=this.radius/60;

        this.sx=0.6;
        this.sy=1.6;
        this.svx=0;
        this.svy=0;
        this.rot=rnd(-8,8);
        this.rotV=rnd(-60,60);
        this.born=performance.now();

        this.el=document.createElement("div");
        this.el.className="message-ball";
        this.el.textContent=text;
        this.el.style.width=this.el.style.height=this.radius*2+"px";

        const h=rnd(0,360);
        this.el.style.background=`radial-gradient(circle at 30% 30%, hsl(${h} 70% 88%), hsl(${h} 70% 72%))`;
        ballContainer.appendChild(this.el);
    }

    update(dt,now){
        this.vx*=WORLD.drag;
        this.vy*=WORLD.drag;

        this.vx+=Math.sin(now*0.001+this.id)*WORLD.noise*dt;
        this.vy+=Math.cos(now*0.001+this.id)*WORLD.noise*dt;

        const sp=Math.hypot(this.vx,this.vy);
        if(sp>WORLD.maxSpeed){
            const k=WORLD.maxSpeed/sp;
            this.vx*=k; this.vy*=k;
        }

        this.x+=this.vx*dt;
        this.y+=this.vy*dt;

        if(this.x<this.radius){this.x=this.radius;this.vx*=-0.6;}
        if(this.x>containerWidth-this.radius){this.x=containerWidth-this.radius;this.vx*=-0.6;}
        if(this.y<this.radius){this.y=this.radius;this.vy*=-0.6;}
        if(this.y>containerHeight-this.radius){this.y=containerHeight-this.radius;this.vy*=-0.6;}

        const bornT=clamp((now-this.born)/350,0,1);
        const pop=Math.sin(bornT*Math.PI)*0.6;
        const tx=1+pop, ty=1-pop;

        this.svx+=(tx-this.sx)*30*dt;
        this.svy+=(ty-this.sy)*30*dt;
        this.svx*=Math.exp(-10*dt);
        this.svy*=Math.exp(-10*dt);
        this.sx+=this.svx*dt;
        this.sy+=this.svy*dt;

        this.rot+=this.rotV*dt;
        this.rotV*=Math.exp(-4*dt);

        this.el.style.transform=
            `translate(${this.x-this.radius}px,${this.y-this.radius}px)
             rotate(${this.rot}deg)
             scale(${this.sx},${this.sy})`;
    }
}

/* =====================================================
   BALLS
===================================================== */
let balls=[];

function addBall(message,isNew){
    const x=CANNON.x;
    const y=CANNON.y();
    const b=new Ball(message.id,message.content,x,y);

    if(isNew){
        const speed=520+rnd(0,200);
        b.vx=Math.cos(CANNON.angle)*speed;
        b.vy=Math.sin(CANNON.angle)*speed;
        b.rotV+=rnd(-200,200);

        balls.forEach(o=>{
            const dx=o.x-x, dy=o.y-y;
            const d=Math.hypot(dx,dy);
            if(d<260 && d>0){
                const f=120/d;
                o.vx+=dx/d*f;
                o.vy+=dy/d*f;
            }
        });

        cannonFire();
    }
    balls.push(b);
}

/* =====================================================
   MAIN LOOP
===================================================== */
let last=performance.now();
function loop(now){
    const dt=Math.min(0.05,(now-last)/1000);
    last=now;

    balls.forEach(b=>b.update(dt,now));
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =====================================================
   SOCKET
===================================================== */
const socket=io();

socket.on("connect", async ()=>{
    const res=await fetch("/api/messages");
    const msgs=await res.json();
    msgs.forEach(m=>{
        const b=new Ball(m.id,m.content,rnd(0,containerWidth),rnd(0,containerHeight));
        balls.push(b);
    });
});

socket.on("newMessage", msg=>{
    setTimeout(()=>addBall(msg,true),120);
});

/* =====================================================
   CANNON EFFECT (MAX)
===================================================== */
const effectCanvas=document.getElementById("effectCanvas");
const ctx=effectCanvas.getContext("2d");
function resizeEffect(){
    effectCanvas.width=innerWidth;
    effectCanvas.height=innerHeight;
}
resizeEffect(); addEventListener("resize",resizeEffect);

let particles=[];
function cannonFire(){
    const sx=CANNON.x;
    const sy=CANNON.y();

    for(let i=0;i<120;i++){
        const a=rnd(-Math.PI,Math.PI);
        const s=rnd(120,520);
        particles.push({
            x:sx,y:sy,
            vx:Math.cos(a)*s,
            vy:Math.sin(a)*s,
            life:1,
            r:rnd(2,6)
        });
    }
}

function drawEffects(){
    ctx.clearRect(0,0,effectCanvas.width,effectCanvas.height);
    particles.forEach(p=>{
        p.x+=p.vx*0.016;
        p.y+=p.vy*0.016;
        p.vy+=420*0.016;
        p.life-=0.03;
        ctx.fillStyle=`rgba(255,180,220,${p.life})`;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
    });
    particles=particles.filter(p=>p.life>0);
    requestAnimationFrame(drawEffects);
}
drawEffects();
</script>
</body>
</html>
