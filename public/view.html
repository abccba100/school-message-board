<!DOCTYPE html>
<html lang="ko" style="color-scheme: light only; background-color: #ffd7e2; color: #333333;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light">
    <meta name="supported-color-schemes" content="light">
    <meta name="theme-color" content="#ffd7e2" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#ffd7e2" media="(prefers-color-scheme: dark)">
    <title>말랑말랑 메시지 보드</title>
    <link rel="stylesheet" href="style.css">
    <style>
        html {
            color-scheme: light only !important;
            background-color: #ffd7e2 !important;
            color: #333333 !important;
            -webkit-color-scheme: light only !important;
        }
        body {
            background:
                radial-gradient(circle at 0% 0%, rgba(255, 255, 255, 0.85) 0, rgba(255, 255, 255, 0) 55%),
                radial-gradient(circle at 100% 100%, rgba(255, 255, 255, 0.9) 0, rgba(255, 255, 255, 0) 55%),
                linear-gradient(135deg, #ffd7e2 0%, #ffe8c7 35%, #e0f2ff 75%, #e3dcff 100%) !important;
            background-color: #ffd7e2 !important;
            color: #333333 !important;
        }

        .bg-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: -3;
            pointer-events: none;
        }

        .effect-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9998;
            pointer-events: none;
        }
    </style>
</head>
<body class="view-page" style="background: linear-gradient(135deg, #ffd7e2 0%, #ffe8c7 35%, #e0f2ff 75%, #e3dcff 100%); background-color: #ffd7e2; color: #333333;">
    <canvas id="bgCanvas" class="bg-canvas" aria-hidden="true"></canvas>
    <canvas id="effectCanvas" class="effect-canvas" aria-hidden="true"></canvas>
    <div class="bg-orbs" aria-hidden="true">
        <span class="orb o1"></span>
        <span class="orb o2"></span>
        <span class="orb o3"></span>
        <span class="orb o4"></span>
    </div>
    <div class="view-hero" aria-label="페이지 안내">
        <div class="hero-kicker">DSM 졸업 축하 메시지</div>
        <div class="hero-title">여러분의 축하가 모이고 있어요</div>
        <p class="hero-subtitle">떠다니는 메시지 공을 바라보며 함께 축하해요.</p>
    </div>
    <div id="ballContainer"></div>
    <div id="status"></div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="client-view.js"></script>
    <script>
        (() => {
            const canvas = document.getElementById('bgCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
            if (!ctx) return;

            const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const DPR = Math.min(2, window.devicePixelRatio || 1);

            let w = 0, h = 0;
            let rafId = 0;
            let last = performance.now();

            const rnd = (a, b) => a + Math.random() * (b - a);
            const palette = [
                [255, 156, 200],
                [255, 206, 150],
                [165, 222, 255],
                [215, 198, 255],
                [202, 255, 220],
            ];

            const blobs = Array.from({ length: 16 }, () => {
                const c = palette[(Math.random() * palette.length) | 0];
                const size = rnd(120, 320);
                return {
                    x: rnd(0, 1),
                    y: rnd(0, 1),
                    r: size,
                    a: rnd(0.045, 0.11),
                    vx: rnd(-0.012, 0.012),
                    vy: rnd(-0.012, 0.012),
                    p: rnd(0, Math.PI * 2),
                    ps: rnd(0.07, 0.14),
                    c,
                };
            });

            function resize() {
                w = Math.max(1, window.innerWidth);
                h = Math.max(1, window.innerHeight);
                canvas.width = Math.floor(w * DPR);
                canvas.height = Math.floor(h * DPR);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            }

            function draw(now) {
                const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
                last = now;

                ctx.clearRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'lighter';

                for (let i = 0; i < blobs.length; i++) {
                    const b = blobs[i];
                    b.p += b.ps * dt;

                    if (!prefersReduced) {
                        b.x += b.vx * dt;
                        b.y += b.vy * dt;
                    }

                    if (b.x < -0.15) b.x = 1.15;
                    if (b.x > 1.15) b.x = -0.15;
                    if (b.y < -0.15) b.y = 1.15;
                    if (b.y > 1.15) b.y = -0.15;

                    const px = b.x * w + Math.sin(b.p) * 20;
                    const py = b.y * h + Math.cos(b.p * 0.9) * 18;
                    const rr = b.r * (0.92 + Math.sin(b.p * 0.75) * 0.08);

                    const g = ctx.createRadialGradient(px - rr * 0.2, py - rr * 0.18, rr * 0.12, px, py, rr);
                    g.addColorStop(0, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},${b.a})`);
                    g.addColorStop(0.7, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},${b.a * 0.5})`);
                    g.addColorStop(1, `rgba(${b.c[0]},${b.c[1]},${b.c[2]},0)`);

                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(px, py, rr, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = 'source-over';
                rafId = requestAnimationFrame(draw);
            }

            resize();
            window.addEventListener('resize', resize, { passive: true });
            rafId = requestAnimationFrame(draw);
        })();

        // Launch Effect Animation - Bottom Left Corner
        (() => {
            const canvas = document.getElementById('effectCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d', { alpha: true });
            if (!ctx) return;

            const DPR = Math.min(2, window.devicePixelRatio || 1);
            let w = 0, h = 0;
            let rafId = 0;
            let last = performance.now();

            const rnd = (a, b) => a + Math.random() * (b - a);

            const colorPalette = [
                [255, 107, 178],
                [255, 165, 0],
                [138, 203, 255],
                [186, 148, 255],
                [255, 223, 0],
                [100, 255, 150],
                [255, 100, 100],
                [100, 200, 255],
            ];

            let particles = [];
            let stars = [];
            let rings = [];
            let trails = [];
            let flyTrails = [];
            let flySparkles = [];
            
            let launchPoint = { x: 0, y: 0 };

            function resize() {
                w = Math.max(1, window.innerWidth);
                h = Math.max(1, window.innerHeight);
                canvas.width = Math.floor(w * DPR);
                canvas.height = Math.floor(h * DPR);
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

                launchPoint.x = 80;
                launchPoint.y = h - 80;
                
                // 발사 방향 재계산 (왼쪽 아래 → 화면 중앙)
                launchAngle = Math.atan2((h * 0.5) - launchPoint.y, (w * 0.5) - launchPoint.x);
            }

            // 발사 방향 (왼쪽 아래 → 화면 중앙)
            let launchAngle = Math.atan2(-h * 0.5, w * 0.5);
            
            function createLaunchBurst() {
                const count = 90;
                const angle = launchAngle;
                
                // 발사 방향 주변으로 퍼지는 파티클 (더 많고 더 화려하게)
                for (let i = 0; i < count; i++) {
                    const spreadAngle = angle + rnd(-0.8, 0.8);
                    const speed = rnd(6, 24);
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    
                    particles.push({
                        x: launchPoint.x + rnd(-10, 10),
                        y: launchPoint.y + rnd(-10, 10),
                        vx: Math.cos(spreadAngle) * speed,
                        vy: Math.sin(spreadAngle) * speed,
                        radius: rnd(3, 12),
                        color: color,
                        life: 1.0,
                        decay: rnd(0.012, 0.028),
                        glow: true
                    });
                }
                
                // 전방향 폭발 (원형으로 퍼지는 추가 파티클)
                for (let i = 0; i < 40; i++) {
                    const spreadAngle = rnd(0, Math.PI * 2);
                    const speed = rnd(4, 14);
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    
                    particles.push({
                        x: launchPoint.x,
                        y: launchPoint.y,
                        vx: Math.cos(spreadAngle) * speed,
                        vy: Math.sin(spreadAngle) * speed,
                        radius: rnd(2, 7),
                        color: color,
                        life: 1.0,
                        decay: rnd(0.02, 0.04),
                        glow: true
                    });
                }

                // 원형 폭발 링 (더 많이)
                for (let i = 0; i < 7; i++) {
                    rings.push({
                        x: launchPoint.x,
                        y: launchPoint.y,
                        radius: 0,
                        maxRadius: rnd(80, 220),
                        speed: rnd(4, 12),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        width: rnd(4, 12)
                    });
                }
                
                // 발사 지점 플래시 (밝은 원형 글로우)
                for (let i = 0; i < 3; i++) {
                    flyTrails.push({
                        x: launchPoint.x + rnd(-5, 5),
                        y: launchPoint.y + rnd(-5, 5),
                        vx: rnd(-3, 3),
                        vy: rnd(-3, 3),
                        radius: rnd(20, 40),
                        color: [255, 255, 255],
                        life: 1.0,
                        decay: rnd(0.04, 0.07),
                    });
                }
            }

            function createStarBurst() {
                const count = 35;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i / count) + rnd(-0.3, 0.3);
                    const distance = rnd(20, 70);
                    
                    stars.push({
                        x: launchPoint.x + Math.cos(angle) * distance,
                        y: launchPoint.y + Math.sin(angle) * distance,
                        size: rnd(10, 26),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        rotation: rnd(0, Math.PI * 2),
                        rotationSpeed: rnd(-0.3, 0.3)
                    });
                }
            }

            function createSparkTrail() {
                const count = 30;
                const angle = launchAngle;
                
                for (let i = 0; i < count; i++) {
                    const distance = i * 12;
                    trails.push({
                        x: launchPoint.x + Math.cos(angle) * distance + rnd(-8, 8),
                        y: launchPoint.y + Math.sin(angle) * distance + rnd(-8, 8),
                        vx: Math.cos(angle) * rnd(3, 8) + rnd(-2, 2),
                        vy: Math.sin(angle) * rnd(3, 8) + rnd(-2, 2),
                        radius: rnd(5, 16),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        decay: rnd(0.015, 0.035),
                        glow: true
                    });
                }
                
                // 추가: 발사 방향으로 빠른 미니 반짝이
                for (let i = 0; i < 15; i++) {
                    const sparkColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    flySparkles.push({
                        x: launchPoint.x + rnd(-15, 15),
                        y: launchPoint.y + rnd(-15, 15),
                        vx: Math.cos(angle) * rnd(40, 100) + rnd(-30, 30),
                        vy: Math.sin(angle) * rnd(40, 100) + rnd(-30, 30),
                        radius: rnd(2, 5),
                        color: sparkColor,
                        life: 1.0,
                        decay: rnd(0.03, 0.06),
                        twinkle: rnd(10, 20),
                        twinklePhase: rnd(0, Math.PI * 2),
                    });
                }
            }

            // 비행 중 트레일 파티클 생성 (client-view.js에서 호출)
            let lastTrailTime = 0;
            function emitTrail(x, y, vx, vy, hue, progress) {
                const now = performance.now();
                if (now - lastTrailTime < 16) return; // 60fps에 맞춰 더 자주 생성
                lastTrailTime = now;
                
                // HSL -> RGB 변환 (파스텔)
                const hNorm = hue / 360;
                const s = 0.7;
                const l = 0.7;
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                const hue2rgb = (pp, qq, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return pp + (qq - pp) * 6 * t;
                    if (t < 1/2) return qq;
                    if (t < 2/3) return pp + (qq - pp) * (2/3 - t) * 6;
                    return pp;
                };
                const ballColor = [
                    Math.round(hue2rgb(p, q, hNorm + 1/3) * 255),
                    Math.round(hue2rgb(p, q, hNorm) * 255),
                    Math.round(hue2rgb(p, q, hNorm - 1/3) * 255)
                ];
                
                const speed = Math.hypot(vx, vy);
                const intensity = 1.0 - (progress || 0); // 초반에 더 강하게
                const count = Math.max(3, Math.min(10, Math.floor(speed / 100 * intensity + 2)));
                
                // 메인 글로우 트레일 (공 색상)
                for (let i = 0; i < count; i++) {
                    flyTrails.push({
                        x: x + rnd(-12, 12),
                        y: y + rnd(-12, 12),
                        vx: -vx * rnd(0.02, 0.08) + rnd(-20, 20),
                        vy: -vy * rnd(0.02, 0.08) + rnd(-20, 20),
                        radius: rnd(4, 14) * intensity + 2,
                        color: ballColor,
                        life: 1.0,
                        decay: rnd(0.018, 0.04),
                    });
                }
                
                // 컬러 트레일 (랜덤 팔레트 색상)
                for (let i = 0; i < Math.ceil(count * 0.5); i++) {
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    flyTrails.push({
                        x: x + rnd(-18, 18),
                        y: y + rnd(-18, 18),
                        vx: -vx * rnd(0.01, 0.04) + rnd(-25, 25),
                        vy: -vy * rnd(0.01, 0.04) + rnd(-25, 25),
                        radius: rnd(3, 8) * intensity + 1,
                        color: color,
                        life: 1.0,
                        decay: rnd(0.025, 0.055),
                    });
                }
                
                // 반짝이 (더 많이, 주변으로 넓게)
                const sparkCount = Math.max(1, Math.floor(3 * intensity));
                for (let i = 0; i < sparkCount; i++) {
                    const sparkColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    flySparkles.push({
                        x: x + rnd(-20, 20),
                        y: y + rnd(-20, 20),
                        vx: rnd(-50, 50),
                        vy: rnd(-50, 50),
                        radius: rnd(1.5, 4.5),
                        color: sparkColor,
                        life: 1.0,
                        decay: rnd(0.035, 0.07),
                        twinkle: rnd(8, 18),
                        twinklePhase: rnd(0, Math.PI * 2),
                    });
                }
                
                // 미니 별 (더 자주 등장)
                if (Math.random() < 0.3) {
                    stars.push({
                        x: x + rnd(-25, 25),
                        y: y + rnd(-25, 25),
                        size: rnd(5, 14),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        rotation: rnd(0, Math.PI * 2),
                        rotationSpeed: rnd(-0.4, 0.4)
                    });
                }
                
                // 가끔 비행 경로에 미니 링
                if (Math.random() < 0.12 && intensity > 0.3) {
                    rings.push({
                        x: x,
                        y: y,
                        radius: 0,
                        maxRadius: rnd(25, 55),
                        speed: rnd(3, 6),
                        color: ballColor,
                        life: 1.0,
                        width: rnd(1.5, 3.5)
                    });
                }
            }
            
            // 도착 시 폭발 효과 (더 화려하게)
            function createArrivalBurst(x, y) {
                // 원형 폭발 파티클
                const count = 50;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i / count) + rnd(-0.2, 0.2);
                    const speed = rnd(20, 140);
                    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    
                    particles.push({
                        x: x + rnd(-5, 5),
                        y: y + rnd(-5, 5),
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: rnd(3, 10),
                        color: color,
                        life: 1.0,
                        decay: rnd(0.015, 0.035),
                        glow: true
                    });
                }
                
                // 도착 링 (더 크고 더 많이)
                for (let i = 0; i < 5; i++) {
                    rings.push({
                        x: x,
                        y: y,
                        radius: 0,
                        maxRadius: rnd(50, 180),
                        speed: rnd(3, 10),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        width: rnd(3, 8)
                    });
                }
                
                // 도착 별
                for (let i = 0; i < 18; i++) {
                    const angle = (Math.PI * 2 * i / 18) + rnd(-0.3, 0.3);
                    const distance = rnd(12, 60);
                    stars.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        size: rnd(7, 18),
                        color: colorPalette[Math.floor(Math.random() * colorPalette.length)],
                        life: 1.0,
                        rotation: rnd(0, Math.PI * 2),
                        rotationSpeed: rnd(-0.35, 0.35)
                    });
                }
                
                // 도착 플래시 글로우
                for (let i = 0; i < 4; i++) {
                    flyTrails.push({
                        x: x + rnd(-8, 8),
                        y: y + rnd(-8, 8),
                        vx: rnd(-5, 5),
                        vy: rnd(-5, 5),
                        radius: rnd(15, 35),
                        color: [255, 255, 255],
                        life: 1.0,
                        decay: rnd(0.04, 0.07),
                    });
                }
                
                // 도착 반짝이
                for (let i = 0; i < 12; i++) {
                    const sparkColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    flySparkles.push({
                        x: x + rnd(-20, 20),
                        y: y + rnd(-20, 20),
                        vx: rnd(-60, 60),
                        vy: rnd(-60, 60),
                        radius: rnd(2, 5),
                        color: sparkColor,
                        life: 1.0,
                        decay: rnd(0.03, 0.06),
                        twinkle: rnd(10, 20),
                        twinklePhase: rnd(0, Math.PI * 2),
                    });
                }
            }

            function fire() {
                createLaunchBurst();
                createStarBurst();
                createSparkTrail();
            }

            function update(dt) {
                // Update trails
                for (let i = trails.length - 1; i >= 0; i--) {
                    const t = trails[i];
                    t.x += t.vx;
                    t.y += t.vy;
                    t.vx *= 0.96;
                    t.vy *= 0.96;
                    t.life -= t.decay;

                    if (t.life <= 0) {
                        trails.splice(i, 1);
                    }
                }

                // Update particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.25;
                    p.vx *= 0.96;
                    p.vy *= 0.96;
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }

                // Update stars
                for (let i = stars.length - 1; i >= 0; i--) {
                    const s = stars[i];
                    s.rotation += s.rotationSpeed;
                    s.life -= 0.018;

                    if (s.life <= 0) {
                        stars.splice(i, 1);
                    }
                }

                // Update rings
                for (let i = rings.length - 1; i >= 0; i--) {
                    const r = rings[i];
                    r.radius += r.speed;
                    r.life -= 0.015;

                    if (r.radius >= r.maxRadius || r.life <= 0) {
                        rings.splice(i, 1);
                    }
                }
                
                // Update fly trails (비행 트레일)
                for (let i = flyTrails.length - 1; i >= 0; i--) {
                    const ft = flyTrails[i];
                    ft.x += ft.vx * dt;
                    ft.y += ft.vy * dt;
                    ft.vy += 8 * dt;
                    ft.vx *= Math.exp(-2.0 * dt);
                    ft.vy *= Math.exp(-2.0 * dt);
                    ft.life -= ft.decay;
                    ft.radius *= Math.exp(-0.8 * dt);
                    
                    if (ft.life <= 0 || ft.radius < 0.5) {
                        flyTrails.splice(i, 1);
                    }
                }
                
                // Update fly sparkles (반짝이)
                for (let i = flySparkles.length - 1; i >= 0; i--) {
                    const sp = flySparkles[i];
                    sp.x += sp.vx * dt;
                    sp.y += sp.vy * dt;
                    sp.vy += 12 * dt;
                    sp.vx *= Math.exp(-3.0 * dt);
                    sp.vy *= Math.exp(-1.5 * dt);
                    sp.life -= sp.decay;
                    sp.twinklePhase += sp.twinkle * dt;
                    
                    if (sp.life <= 0) {
                        flySparkles.splice(i, 1);
                    }
                }
            }

            function drawStar(x, y, size, rotation, alpha) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i / 5) - Math.PI / 2;
                    const outerX = Math.cos(angle) * size;
                    const outerY = Math.sin(angle) * size;
                    const innerAngle = angle + Math.PI / 5;
                    const innerX = Math.cos(innerAngle) * (size * 0.4);
                    const innerY = Math.sin(innerAngle) * (size * 0.4);
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                ctx.restore();
            }

            function draw(now) {
                const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
                last = now;

                ctx.clearRect(0, 0, w, h);

                update(dt);

                // Draw rings
                for (const r of rings) {
                    const alpha = r.life * (1 - r.radius / r.maxRadius);
                    
                    const gradient = ctx.createRadialGradient(r.x, r.y, r.radius - r.width, r.x, r.y, r.radius + r.width);
                    gradient.addColorStop(0, `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, 0)`);
                    gradient.addColorStop(0.5, `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, ${alpha * 0.4})`);
                    gradient.addColorStop(1, `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, 0)`);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = r.width * 2;
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, ${alpha})`;
                    ctx.lineWidth = r.width;
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw fly trails (비행 트레일 - 부드러운 글로우)
                for (const ft of flyTrails) {
                    const alpha = ft.life;
                    
                    // 외부 글로우
                    const gradient = ctx.createRadialGradient(ft.x, ft.y, 0, ft.x, ft.y, ft.radius * 3.5);
                    gradient.addColorStop(0, `rgba(${ft.color[0]}, ${ft.color[1]}, ${ft.color[2]}, ${alpha * 0.7})`);
                    gradient.addColorStop(0.4, `rgba(${ft.color[0]}, ${ft.color[1]}, ${ft.color[2]}, ${alpha * 0.3})`);
                    gradient.addColorStop(1, `rgba(${ft.color[0]}, ${ft.color[1]}, ${ft.color[2]}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(ft.x, ft.y, ft.radius * 3.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 코어
                    ctx.fillStyle = `rgba(${ft.color[0]}, ${ft.color[1]}, ${ft.color[2]}, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(ft.x, ft.y, ft.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 밝은 중심
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(ft.x, ft.y, ft.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw fly sparkles (반짝이)
                for (const sp of flySparkles) {
                    const twinkleAlpha = (Math.sin(sp.twinklePhase) * 0.5 + 0.5);
                    const alpha = sp.life * twinkleAlpha;
                    
                    if (alpha > 0.05) {
                        // 십자 모양 반짝이
                        ctx.save();
                        ctx.translate(sp.x, sp.y);
                        
                        const size = sp.radius * (1 + twinkleAlpha * 0.5);
                        
                        // 수직선
                        ctx.strokeStyle = `rgba(${sp.color[0]}, ${sp.color[1]}, ${sp.color[2]}, ${alpha})`;
                        ctx.lineWidth = 1.2;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 2);
                        ctx.lineTo(0, size * 2);
                        ctx.stroke();
                        
                        // 수평선
                        ctx.beginPath();
                        ctx.moveTo(-size * 2, 0);
                        ctx.lineTo(size * 2, 0);
                        ctx.stroke();
                        
                        // 중심 글로우
                        const sparkGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 1.5);
                        sparkGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.8})`);
                        sparkGradient.addColorStop(0.5, `rgba(${sp.color[0]}, ${sp.color[1]}, ${sp.color[2]}, ${alpha * 0.4})`);
                        sparkGradient.addColorStop(1, `rgba(${sp.color[0]}, ${sp.color[1]}, ${sp.color[2]}, 0)`);
                        ctx.fillStyle = sparkGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }

                // Draw trails
                for (const t of trails) {
                    const alpha = t.life;
                    
                    if (t.glow) {
                        const gradient = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.radius * 3);
                        gradient.addColorStop(0, `rgba(${t.color[0]}, ${t.color[1]}, ${t.color[2]}, ${alpha * 0.9})`);
                        gradient.addColorStop(0.5, `rgba(${t.color[0]}, ${t.color[1]}, ${t.color[2]}, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(${t.color[0]}, ${t.color[1]}, ${t.color[2]}, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, t.radius * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.fillStyle = `rgba(${t.color[0]}, ${t.color[1]}, ${t.color[2]}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw particles
                for (const p of particles) {
                    const alpha = p.life;
                    
                    if (p.glow) {
                        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 4);
                        gradient.addColorStop(0, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.8})`);
                        gradient.addColorStop(0.5, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.4})`);
                        gradient.addColorStop(1, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw stars
                for (const s of stars) {
                    const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 3);
                    gradient.addColorStop(0, `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, ${s.life * 0.8})`);
                    gradient.addColorStop(1, `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    drawStar(s.x, s.y, s.size, s.rotation, s.life);
                }

                rafId = requestAnimationFrame(draw);
            }

            resize();
            window.addEventListener('resize', resize, { passive: true });
            rafId = requestAnimationFrame(draw);

            // Expose fire and emitTrail functions globally
            window.launchEffect = { fire, emitTrail, createArrivalBurst };
        })();
    </script>
</body>
</html>
